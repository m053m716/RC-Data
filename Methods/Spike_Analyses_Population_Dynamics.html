<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html; charset=utf-8"><meta http-equiv="X-UA-Compatible" content="IE=edge,IE=9,chrome=1"><meta name="generator" content="MATLAB 2020b"><title>jPCA: A Guide</title><style type="text/css">.rtcContent { padding: 30px; } .S0 { margin: 3px 10px 5px 4px; padding: 0px; line-height: 28.8px; min-height: 0px; white-space: pre-wrap; color: rgb(213, 80, 0); font-family: Helvetica, Arial, sans-serif; font-style: normal; font-size: 24px; font-weight: 400; text-align: left;  }
.S1 { margin: 2px 10px 9px 4px; padding: 0px; line-height: 21px; min-height: 0px; white-space: pre-wrap; color: rgb(0, 0, 0); font-family: Helvetica, Arial, sans-serif; font-style: normal; font-size: 14px; font-weight: 400; text-align: left;  }
.CodeBlock { background-color: #F7F7F7; margin: 10px 0 10px 0;}
.S2 { border-left: 1px solid rgb(233, 233, 233); border-right: 1px solid rgb(233, 233, 233); border-top: 1px solid rgb(233, 233, 233); border-bottom: 1px solid rgb(233, 233, 233); border-radius: 4px; padding: 6px 45px 4px 13px; line-height: 17.234px; min-height: 18px; white-space: nowrap; color: rgb(0, 0, 0); font-family: Menlo, Monaco, Consolas, "Courier New", monospace; font-size: 14px;  }
.S3 { margin: 10px 10px 9px 4px; padding: 0px; line-height: 21px; min-height: 0px; white-space: pre-wrap; color: rgb(0, 0, 0); font-family: Helvetica, Arial, sans-serif; font-style: normal; font-size: 14px; font-weight: 400; text-align: left;  }
.S4 { margin: 20px 10px 5px 4px; padding: 0px; line-height: 20px; min-height: 0px; white-space: pre-wrap; color: rgb(60, 60, 60); font-family: Helvetica, Arial, sans-serif; font-style: normal; font-size: 20px; font-weight: 700; text-align: left;  }
.S5 { border-left: 1px solid rgb(233, 233, 233); border-right: 1px solid rgb(233, 233, 233); border-top: 1px solid rgb(233, 233, 233); border-bottom: 0px none rgb(0, 0, 0); border-radius: 4px 4px 0px 0px; padding: 6px 45px 0px 13px; line-height: 17.234px; min-height: 18px; white-space: nowrap; color: rgb(0, 0, 0); font-family: Menlo, Monaco, Consolas, "Courier New", monospace; font-size: 14px;  }
.S6 { border-left: 1px solid rgb(233, 233, 233); border-right: 1px solid rgb(233, 233, 233); border-top: 0px none rgb(0, 0, 0); border-bottom: 0px none rgb(0, 0, 0); border-radius: 0px; padding: 0px 45px 0px 13px; line-height: 17.234px; min-height: 18px; white-space: nowrap; color: rgb(0, 0, 0); font-family: Menlo, Monaco, Consolas, "Courier New", monospace; font-size: 14px;  }
.S7 { border-left: 1px solid rgb(233, 233, 233); border-right: 1px solid rgb(233, 233, 233); border-top: 0px none rgb(0, 0, 0); border-bottom: 1px solid rgb(233, 233, 233); border-radius: 0px 0px 4px 4px; padding: 0px 45px 4px 13px; line-height: 17.234px; min-height: 18px; white-space: nowrap; color: rgb(0, 0, 0); font-family: Menlo, Monaco, Consolas, "Courier New", monospace; font-size: 14px;  }
.S8 { margin: 3px 10px 5px 4px; padding: 0px; line-height: 20px; min-height: 0px; white-space: pre-wrap; color: rgb(60, 60, 60); font-family: Helvetica, Arial, sans-serif; font-style: normal; font-size: 20px; font-weight: 700; text-align: left;  }
.S9 { margin: 15px 10px 5px 4px; padding: 0px; line-height: 18px; min-height: 0px; white-space: pre-wrap; color: rgb(60, 60, 60); font-family: Helvetica, Arial, sans-serif; font-style: normal; font-size: 17px; font-weight: 700; text-align: left;  }
.S10 { margin: 10px 0px 20px; padding-left: 0px; font-family: Helvetica, Arial, sans-serif; font-size: 14px;  }
.S11 { margin-left: 56px; line-height: 21px; min-height: 0px; text-align: left; white-space: pre-wrap;  }
.S12 { margin: 3px 10px 5px 4px; padding: 0px; line-height: 18px; min-height: 0px; white-space: pre-wrap; color: rgb(60, 60, 60); font-family: Helvetica, Arial, sans-serif; font-style: normal; font-size: 17px; font-weight: 700; text-align: left;  }
.S13 { margin: 10px 10px 5px 4px; padding: 0px; line-height: 18px; min-height: 0px; white-space: pre-wrap; color: rgb(60, 60, 60); font-family: Helvetica, Arial, sans-serif; font-style: normal; font-size: 15px; font-weight: 700; text-align: left;  }</style></head><body><div class = rtcContent><h1  class = 'S0'><span style=' font-weight: bold;'>jPCA</span><span>: </span><span style=' font-style: italic;'>A Guide</span></h1><div  class = 'S1'><span>Click </span><span style=' font-weight: bold; font-family: monospace;'>Run</span><span> to run the full script. Otherwise, step through (section by section) to adjust parameters as desired.</span></div><div class="CodeBlock"><div class="inlineWrapper"><div  class = 'S2'><span> </span><span style="white-space: pre;"><span> </span><span style="color: rgb(2, 128, 9);">% Runs all analyses in this live-script</span></span></div></div></div><div  class = 'S3'><span>Many of the population-level analyses that are described in assessments of neurophysiological spiking population dynamics seek to interpret not necessarily the mean firing rate, which indeed co-varies most strongly with specific elements of behavior, but rather, the unaccounted variance in underlying processes (sometimes referred to as factors), which might otherwise be better explained when viewed in covariance of overall population "dispersion" under certain task-specific conditions. This script tries to walk through that process in a sensible way.</span></div><h2  class = 'S4'><span>Initialize </span><span style=' font-weight: bold; font-family: monospace;'>jPCA</span><span> Data</span></h2><div  class = 'S1'><span>Click </span><span style=' font-weight: bold; font-family: monospace;'>Initialize</span><span> to run the current section. Doing so will initialize the main data table, excluding unwanted grouping categories (e.g. trials where no pellet was present).</span></div><div class="CodeBlock"><div class="inlineWrapper"><div  class = 'S2'><span> </span><span style="white-space: pre;"><span> </span><span style="color: rgb(2, 128, 9);">% Only runs the current section</span></span></div></div></div><div  class = 'S3'><span>Clear workspace &amp; load data</span></div><div class="CodeBlock"><div class="inlineWrapper"><div  class = 'S5'><span style="white-space: pre;"><span>clear</span></span></div></div><div class="inlineWrapper"><div  class = 'S6'><span style="white-space: pre;"><span>load(defaults.files(</span><span style="color: rgb(170, 4, 249);">'rate_table_default_matfile'</span><span>),</span><span style="color: rgb(170, 4, 249);">'T'</span><span>); </span><span style="color: rgb(2, 128, 9);">% Load can take a few minutes</span></span></div></div><div class="inlineWrapper"><div  class = 'S7'><span style="white-space: pre;"><span>M = analyze.marg.get_subset(T); </span><span style="color: rgb(2, 128, 9);">% Reduce to relevant subset</span></span></div></div></div><h2  class = 'S8'><span>Remove relevant Marginalizations</span></h2><div  class = 'S1'><span>Click </span><span style=' font-weight: bold; font-family: monospace;'>Marginalize</span><span> to run the current section, creating a data table of mean-subtracted trial rates that corresponds to trials with zero cross-trial average according to the groupings in marginalizations.</span></div><div class="CodeBlock"><div class="inlineWrapper"><div  class = 'S5'><span> </span><span style="white-space: pre;"><span> </span><span style="color: rgb(2, 128, 9);">% Run all analyses except for the LOAD step</span></span></div></div><div class="inlineWrapper"><div  class = 'S7'><span> </span><span style="white-space: pre;"><span> </span><span style="color: rgb(2, 128, 9);">% Only runs the current section</span></span></div></div></div><h3  class = 'S9'><span>Subtract group means in a principled way</span></h3><div  class = 'S1'><span>We expect there to be large, striking differences in the observed neurophsyiological spiking time-series, with this being unsurprising for the following marginalizations: </span></div><ul  class = 'S10'><li  class = 'S11'><span>    </span><span style=' font-weight: bold; font-family: monospace;'>Group</span><span> (we expect a difference between Ischemic vs. Intact rats)</span></li><li  class = 'S11'><span>    </span><span style=' font-weight: bold; font-family: monospace;'>Rat </span><span>(we expect a random within-rat difference simply due to different combination of recording channels etc.)</span></li><li  class = 'S11'><span>    </span><span style=' font-weight: bold; font-family: monospace;'>Area</span><span> (we expect a difference on the basis of Premotor vs. Motor area)</span></li><li  class = 'S11'><span>    </span><span style=' font-weight: bold; font-family: monospace;'>ICMS </span><span>(motor representation, such as Forelimb vs. Whiskers)</span></li><li  class = 'S11'><span>    </span><span style=' font-weight: bold; font-family: monospace;'>Channel</span><span> (a huge difference for individual channels)</span></li></ul><div class="CodeBlock"><div class="inlineWrapper"><div  class = 'S5'><span style="white-space: pre;"><span>clearvars </span><span style="color: rgb(170, 4, 249);">-except T M</span></span></div></div><div class="inlineWrapper"><div  class = 'S6'><span style="white-space: pre;"><span>marginalizations = {</span><span style="color: rgb(170, 4, 249);">'AnimalID'</span><span>,</span><span style="color: rgb(170, 4, 249);">'Area'</span><span>,</span><span style="color: rgb(170, 4, 249);">'Channel'</span><span>,</span><span style="color: rgb(170, 4, 249);">'Alignment'</span><span>,</span><span style="color: rgb(170, 4, 249);">'Outcome'</span><span>};</span></span></div></div><div class="inlineWrapper"><div  class = 'S6'><span style="white-space: pre;"><span>outcome = </span><span style="color: rgb(170, 4, 249);">'Successful'</span><span>;</span></span></div></div><div class="inlineWrapper"><div  class = 'S7'><span style="white-space: pre;"><span>min_n_trials = </span></span><span>5</span><span style="white-space: pre;"><span>;</span></span></div></div></div><h3  class = 'S9'><span>Create marginalized dataset</span></h3><div class="CodeBlock"><div class="inlineWrapper"><div  class = 'S5'><span style="white-space: pre;"><span>S = analyze.marg.subtract_rat_means(M,marginalizations);</span></span></div></div><div class="inlineWrapper"><div  class = 'S7'><span style="white-space: pre;"><span>S = utils.filterByNTrials(S,min_n_trials,outcome); </span><span style="color: rgb(2, 128, 9);">% Restrict subset to analyze</span></span></div></div></div><div  class = 'S3'><span>Set parameters:</span></div><ul  class = 'S10'><li  class = 'S11'><span>    </span><span style=' font-weight: bold; font-family: monospace;'>animal</span><span> : Exemplar Animal to use in single-recording jPCA analysis/visualization</span></li><li  class = 'S11'><span>    </span><span style=' font-weight: bold; font-family: monospace;'>align_event</span><span> : Alignment event to use for single-recording jPCA analyses</span></li><li  class = 'S11'><span>    </span><span style=' font-weight: bold; font-family: monospace;'>save_fig </span><span>: Toggle checkbox on if you wish to automatically save the generated figure</span></li><li  class = 'S11'><span>    </span><span style=' font-weight: bold; font-family: monospace;'>show_pre_mean_subtraction </span><span>: Toggle checkbox on if you want to check pre-mean-subtraction data</span></li></ul><div class="CodeBlock"><div class="inlineWrapper"><div  class = 'S5'><span style="white-space: pre;"><span>animal = </span></span><span style="color: rgb(170, 4, 249);">'RC-14'</span><span style="white-space: pre;"><span>;</span></span></div></div><div class="inlineWrapper"><div  class = 'S6'><span style="white-space: pre;"><span>align_event = </span></span><span style="color: rgb(170, 4, 249);">'Grasp'</span><span style="white-space: pre;"><span>;</span></span></div></div><div class="inlineWrapper"><div  class = 'S6'><span style="white-space: pre;"><span>save_fig = </span></span><span>false</span><span style="white-space: pre;"><span>; </span><span style="color: rgb(2, 128, 9);">% Auto-saves the figure, if ticked</span></span></div></div><div class="inlineWrapper"><div  class = 'S6'><span style="white-space: pre;"><span>show_pre_mean_subtraction = </span></span><span>false</span><span style="white-space: pre;"><span>; </span><span style="color: rgb(2, 128, 9);">% Show same data, prior to mean-subtraction</span></span></div></div><div class="inlineWrapper"><div  class = 'S6'></div></div><div class="inlineWrapper"><div  class = 'S6'><span style="white-space: pre;"><span style="color: rgb(2, 128, 9);">% % Survey of some combinations that I've looked at % %</span></span></div></div><div class="inlineWrapper"><div  class = 'S6'><span style="white-space: pre;"><span style="color: rgb(2, 128, 9);">%   Intact group</span></span></div></div><div class="inlineWrapper"><div  class = 'S6'><span style="white-space: pre;"><span style="color: rgb(2, 128, 9);">% RC-14 - PO-05 - Grasp: same issue as some of Ischemia guys regarding</span></span></div></div><div class="inlineWrapper"><div  class = 'S6'><span style="white-space: pre;"><span style="color: rgb(2, 128, 9);">%       expansions and contractions while still having rotatory structure</span></span></div></div><div class="inlineWrapper"><div  class = 'S6'><span style="white-space: pre;"><span style="color: rgb(2, 128, 9);">% RC-18 - PO-17 - Grasp: looks good in jPCA on Plane-1</span></span></div></div><div class="inlineWrapper"><div  class = 'S6'><span style="white-space: pre;"><span style="color: rgb(2, 128, 9);">% RC-21 - PO-14 - Grasp: looks good in jPCA on Plane-1</span></span></div></div><div class="inlineWrapper"><div  class = 'S6'><span style="white-space: pre;"><span style="color: rgb(2, 128, 9);">% RC-43 - PO-24 - Grasp: looks good in jPCA on Plane-1</span></span></div></div><div class="inlineWrapper"><div  class = 'S6'><span style="white-space: pre;"><span style="color: rgb(2, 128, 9);">%</span></span></div></div><div class="inlineWrapper"><div  class = 'S6'><span style="white-space: pre;"><span style="color: rgb(2, 128, 9);">%   Ischemia group</span></span></div></div><div class="inlineWrapper"><div  class = 'S6'><span style="white-space: pre;"><span style="color: rgb(2, 128, 9);">% RC-02 - PO-17 - Grasp: not as strong jPCA structure on Plane-1</span></span></div></div><div class="inlineWrapper"><div  class = 'S6'><span style="white-space: pre;"><span style="color: rgb(2, 128, 9);">% RC-04 - PO-16 - Grasp: not as strong jPCA structure on Plane-1</span></span></div></div><div class="inlineWrapper"><div  class = 'S6'><span style="white-space: pre;"><span style="color: rgb(2, 128, 9);">% RC-05 - PO-08 - Grasp: not as strong jPCA structure on Plane-1</span></span></div></div><div class="inlineWrapper"><div  class = 'S6'><span style="white-space: pre;"><span style="color: rgb(2, 128, 9);">% RC-08 - PO-16 - Grasp: not as strong jPCA structure on Plane-1</span></span></div></div><div class="inlineWrapper"><div  class = 'S6'><span style="white-space: pre;"><span style="color: rgb(2, 128, 9);">% RC-26 - PO-19 - Grasp: definitely has separation between</span></span></div></div><div class="inlineWrapper"><div  class = 'S6'><span style="white-space: pre;"><span style="color: rgb(2, 128, 9);">%           success/unsuccesful in Plane-1, but has some elements of rotatory</span></span></div></div><div class="inlineWrapper"><div  class = 'S6'><span style="white-space: pre;"><span style="color: rgb(2, 128, 9);">%           structure combined with a lot of expansion/contraction elements.</span></span></div></div><div class="inlineWrapper"><div  class = 'S6'><span style="white-space: pre;"><span style="color: rgb(2, 128, 9);">% RC-30 - PO-16 (&amp; others) - Grasp: has quite good jPCA structure on</span></span></div></div><div class="inlineWrapper"><div  class = 'S6'><span style="white-space: pre;"><span style="color: rgb(2, 128, 9);">%                               Plane-1. Note that on this day, he had many</span></span></div></div><div class="inlineWrapper"><div  class = 'S6'><span style="white-space: pre;"><span style="color: rgb(2, 128, 9);">%                               more successful trials included than</span></span></div></div><div class="inlineWrapper"><div  class = 'S6'><span style="white-space: pre;"><span style="color: rgb(2, 128, 9);">%                               unsuccessful trials, although the variance</span></span></div></div><div class="inlineWrapper"><div  class = 'S6'><span style="white-space: pre;"><span style="color: rgb(2, 128, 9);">%                               captured is lower in general for any of the</span></span></div></div><div class="inlineWrapper"><div  class = 'S6'><span style="white-space: pre;"><span style="color: rgb(2, 128, 9);">%                               visualized planes.</span></span></div></div><div class="inlineWrapper"><div  class = 'S6'><span style="white-space: pre;"><span>[fig_by_Channel,s] = analyze.rec.plot_rate(</span><span style="color: rgb(14, 0, 255);">...</span></span></div></div><div class="inlineWrapper"><div  class = 'S6'><span style="white-space: pre;"><span>    utils.filterByNTrials(S,min_n_trials,outcome,</span><span style="color: rgb(170, 4, 249);">'AnimalID'</span><span>,animal),</span><span style="color: rgb(14, 0, 255);">...</span><span style="color: rgb(2, 128, 9);"> </span></span></div></div><div class="inlineWrapper"><div  class = 'S7'><span style="white-space: pre;"><span>    align_event,outcome,save_fig,1);</span></span></div></div></div><div  class = 'S3'><span>This figure produces subplots for all trials of a single Block. Each subplot represents a different channel. The top two rows represent normalized spike rates on channels that are in Caudal Forelimb Area (CFA; rat M1 homolog) that is ipsilateral to the forelimb retrieving the pellet. The bottom two rows represent normalized spike rates on channels that are in Rostral Forelimb Area (RFA; rat PM homolog) contralateral to the forelimb retrieving the pellet. Time is represented on the x-axis in milliseconds. The bold text above each subplot indicates the approximate intracortical microstimulation (ICMS) co-registration from a mapping procedure done just prior to the insertion of the microwire arrays. It follows the key: </span></div><ul  class = 'S10'><li  class = 'S11'><span style=' font-weight: bold;'>Distal Forelimb</span><span> (DF)</span></li><li  class = 'S11'><span style=' font-weight: bold;'>Proximal Forelimb </span><span>(PF)</span></li><li  class = 'S11'><span style=' font-weight: bold;'>Distal &amp; Proximal Forelimb </span><span>(DF-PF)</span></li><li  class = 'S11'><span style=' font-weight: bold;'>No Response </span><span>(NR; 80 uA maximum current)</span></li><li  class = 'S11'><span style=' font-weight: bold;'>Other</span><span> (O; e.g. Trunk, Vibrissae, Mouth, etc.)</span></li></ul><div  class = 'S1'><span>Verify that the mean-subtracted outcomes make sense; the largest "modulated" component should be the task-aligned one. Since we do not typically see "traditionally" coherent task-related fluctuations, particularly around the 0-ms task alignment, it looks like we correctly subtracted the mean. You can see if there is a difference by toggling the check-box below.</span></div><div class="CodeBlock"><div class="inlineWrapper"><div  class = 'S5'><span style="white-space: pre;"><span style="color: rgb(14, 0, 255);">if </span><span>show_pre_mean_subtraction</span></span></div></div><div class="inlineWrapper"><div  class = 'S6'><span style="white-space: pre;"><span>    </span><span style="color: rgb(2, 128, 9);">% Note that `M` is the pre-subtraction table</span></span></div></div><div class="inlineWrapper"><div  class = 'S6'><span style="white-space: pre;"><span>    [fig_by_Channel_orig] = analyze.rec.plot_rate(M(ismember(M.RowID,s.RowID),:),</span><span style="color: rgb(14, 0, 255);">...</span></span></div></div><div class="inlineWrapper"><div  class = 'S6'><span style="white-space: pre;"><span>        align_event,outcome,save_fig,1); </span><span style="color: rgb(2, 128, 9);">%#ok&lt;UNRCH&gt; </span></span></div></div><div class="inlineWrapper"><div  class = 'S7'><span style="white-space: pre;"><span style="color: rgb(14, 0, 255);">end</span></span></div></div></div><h2  class = 'S8'><span>Apply Population-Level Analysis</span></h2><div  class = 'S1'><span>Click </span><span style=' font-weight: bold; font-family: monospace;'>Convert</span><span> to create the formatted struct for analyzing the spike rates of trials from a single recording using the (modified) Churchland &amp; Cunningham jPCA scripts.</span></div><div class="CodeBlock"><div class="inlineWrapper"><div  class = 'S2'><span> </span><span style="white-space: pre;"><span> </span><span style="color: rgb(2, 128, 9);">% Only runs the current section</span></span></div></div></div><div  class = 'S3'><span>Using our marginalized dataset, we can now apply population-level analysis. A principled approach is detailed in (cite), which describes jPCA, a method that attempts to assess the strength of rotatory dynamics present under the assumption that the population dynamics are the result of factors governed in an oscillatory fashion, which is captured by a system of differential equations as:</span></div><div  class = 'S1'><span>Where  is constrained to be skew-symmetric during the optimization procedure (a least-squares minimization). The recovered fit should then be compared to , which is the optimal solution in the least-squares sense. If the fits are comparable (and that part can be nebulous; in general, it would seem that you want the top pairs of eigenvectors to capture 20-40% of the observed data variance as a seeming rule of thumb).</span></div><h3  class = 'S9'><span>Organize data for jPCA code</span></h3><div  class = 'S1'><span style=' font-style: italic;'>Note that all code in </span><span style=' font-weight: bold; font-style: italic; font-family: monospace;'>analyze.jPCA</span><span style=' font-style: italic;'> is based on code kindly provided by John P. Cunningham &amp; Mark Churchland; it has been changed slightly from the original format to accomodate some optional parameters for visualization purposes, and the documentation is changed to reflect notes as I was learning the material.</span></div><div  class = 'S1'><span style=' font-weight: bold;'>We will use the (small-m) matrix that we inspected rates for above</span></div><div class="CodeBlock"><div class="inlineWrapper"><div  class = 'S5'><span style="white-space: pre;"><span style="color: rgb(14, 0, 255);">if </span><span>exist(</span><span style="color: rgb(170, 4, 249);">'s'</span><span>,</span><span style="color: rgb(170, 4, 249);">'var'</span><span>)==0</span></span></div></div><div class="inlineWrapper"><div  class = 'S6'><span style="white-space: pre;"><span>    error(</span><span style="color: rgb(170, 4, 249);">'Must run previous section prior to this one.'</span><span>)</span></span></div></div><div class="inlineWrapper"><div  class = 'S6'><span style="white-space: pre;"><span style="color: rgb(14, 0, 255);">end</span></span></div></div><div class="inlineWrapper"><div  class = 'S6'><span style="white-space: pre;"><span>area = </span></span><span style="color: rgb(170, 4, 249);">"All"</span><span style="white-space: pre;"><span>;</span></span></div></div><div class="inlineWrapper"><div  class = 'S6'><span style="white-space: pre;"><span>[Data,J,JID] = analyze.jPCA.convert_table(</span><span style="color: rgb(14, 0, 255);">...</span></span></div></div><div class="inlineWrapper"><div  class = 'S6'><span style="white-space: pre;"><span>    s,align_event,area,</span><span style="color: rgb(14, 0, 255);">...</span></span></div></div><div class="inlineWrapper"><div  class = 'S6'><span style="white-space: pre;"><span>    </span><span style="color: rgb(170, 4, 249);">'Outcome'</span><span>,outcome);</span></span></div></div><div class="inlineWrapper"><div  class = 'S6'><span style="white-space: pre;"><span style="color: rgb(14, 0, 255);">if </span><span>isempty(Data)</span></span></div></div><div class="inlineWrapper"><div  class = 'S6'><span style="white-space: pre;"><span>    error(</span><span style="color: rgb(170, 4, 249);">'No trials meet those criteria.'</span><span>);</span></span></div></div><div class="inlineWrapper"><div  class = 'S7'><span style="white-space: pre;"><span style="color: rgb(14, 0, 255);">end</span></span></div></div></div><h3  class = 'S12'><span>Verify </span><span style=' font-weight: bold; font-family: monospace;'>Data</span><span> exported as intended</span></h3><div  class = 'S1'><span>Once the Data struct has been exported for jPCA, click Check Data to plot one of the exported trials, verifying that filtering/interpolating didn't do anything "weird." Click </span><span style=' font-weight: bold; font-family: monospace;'>Run </span><span>to run the current section (</span><span style=' font-style: italic;'>see "</span><span style=' font-weight: bold; font-style: italic;'>Setting</span><span style=' font-style: italic;'> </span><span style=' font-weight: bold; font-style: italic; font-family: monospace;'>jPCA_params"</span><span style=' font-weight: bold; font-style: italic;'> </span><span style=' font-style: italic;'>below)</span><span>.</span></div><div class="CodeBlock"><div class="inlineWrapper"><div  class = 'S5'><span> </span><span style="white-space: pre;"><span> </span><span style="color: rgb(2, 128, 9);">% Run current section (requires `Data` (formatted struct array))</span></span></div></div><div class="inlineWrapper"><div  class = 'S6'><span style="white-space: pre;"><span style="color: rgb(14, 0, 255);">if </span><span>exist(</span><span style="color: rgb(170, 4, 249);">'Data'</span><span>,</span><span style="color: rgb(170, 4, 249);">'var'</span><span>)==0</span></span></div></div><div class="inlineWrapper"><div  class = 'S6'><span style="white-space: pre;"><span>    error(</span><span style="color: rgb(170, 4, 249);">'Must run previous section to extract `Data` first'</span><span>);</span></span></div></div><div class="inlineWrapper"><div  class = 'S7'><span style="white-space: pre;"><span style="color: rgb(14, 0, 255);">end</span></span></div></div></div><h4  class = 'S13'><span style=' font-weight: bold;'>Setting </span><span style=' font-weight: bold; font-family: monospace;'>jPCA_params</span></h4><div  class = 'S1'><span>For jPCA, most parameters are set via the defaults and previously-initialized variables. The following parameters can be toggled as desired:</span></div><ul  class = 'S10'><li  class = 'S11'><span style=' font-weight: bold; font-family: monospace;'>.numPCs</span><span> : Total number of principal components to use for obtaining linearized dynamical system fit.</span></li><li  class = 'S11'><span style=' font-weight: bold; font-family: monospace;'>.PCStem.PlotMeans</span><span> : Toggle to true in order to plot mean PC values for different conditions (outcomes). Only makes sense if using more than one outcome.</span></li></ul><div class="CodeBlock"><div class="inlineWrapper"><div  class = 'S5'><span style="white-space: pre;"><span>jPCA_params = defaults.jPCA(</span><span style="color: rgb(170, 4, 249);">'jpca_params'</span><span>);</span></span></div></div><div class="inlineWrapper"><div  class = 'S6'><span style="white-space: pre;"><span>jPCA_params.numPCs = </span></span><span>12</span><span style="white-space: pre;"><span>; </span><span style="color: rgb(2, 128, 9);">% Note: only increments by **even** values</span></span></div></div><div class="inlineWrapper"><div  class = 'S7'><span style="white-space: pre;"><span>jPCA_params.PCStem.PlotMeans = </span></span><span>false</span><span style="white-space: pre;"><span>; </span><span style="color: rgb(2, 128, 9);">% Plot means if true, otherwise plot individual trials (PCs)</span></span></div></div></div><div  class = 'S3'><span>If you do not wish to see some element of the jPCA output displayed, tick the corresponding checkbox:</span></div><ul  class = 'S10'><li  class = 'S11'><span style=' font-weight: bold; font-family: monospace;'>.suppressPCstem : </span><span>Stem plot showing % of original data explained by selected </span><span style=' font-weight: bold; font-family: monospace;'>.numPCs </span><span>parameter.</span></li><li  class = 'S11'><span style=' font-weight: bold; font-family: monospace;'>.suppressRosettes : </span><span>Arrow "rosette" plots showing individual trial phase trajectories.</span></li><li  class = 'S11'><span style=' font-weight: bold; font-family: monospace;'>.suppressHistograms : </span><span>Phase-angle histogram displays.</span></li><li  class = 'S11'><span style=' font-weight: bold; font-family: monospace;'>.suppressText : </span><span>Formatted text reporting eigenvalues and % of data explained and % variance captured.</span></li></ul><div class="CodeBlock"><div class="inlineWrapper"><div  class = 'S5'><span style="white-space: pre;"><span>jPCA_params.suppressPCstem = </span></span><span>false</span><span style="white-space: pre;"><span>; </span><span style="color: rgb(2, 128, 9);">% Set true to suppress PC stem plot</span></span></div></div><div class="inlineWrapper"><div  class = 'S6'><span style="white-space: pre;"><span>jPCA_params.suppressRosettes = </span></span><span>false</span><span style="white-space: pre;"><span>; </span><span style="color: rgb(2, 128, 9);">% Set true to suppress jPC rosette planar plots</span></span></div></div><div class="inlineWrapper"><div  class = 'S6'><span style="white-space: pre;"><span>jPCA_params.suppressHistograms = </span></span><span>false</span><span style="white-space: pre;"><span>; </span><span style="color: rgb(2, 128, 9);">% Set true to suppress jPC plane phase angle histograms</span></span></div></div><div class="inlineWrapper"><div  class = 'S7'><span style="white-space: pre;"><span>jPCA_params.suppressText = </span></span><span>false</span><span style="white-space: pre;"><span>; </span><span style="color: rgb(2, 128, 9);">% Set true to suppress text output</span></span></div></div></div><div  class = 'S3'><span>For plot titles etc. we associate metadata with the parameters struct, but there are no actual parameters to "set" here:</span></div><div class="CodeBlock"><div class="inlineWrapper"><div  class = 'S5'><span style="white-space: pre;"><span style="color: rgb(14, 0, 255);">if </span><span>exist(</span><span style="color: rgb(170, 4, 249);">'area'</span><span>,</span><span style="color: rgb(170, 4, 249);">'var'</span><span>)~=0</span></span></div></div><div class="inlineWrapper"><div  class = 'S6'><span style="white-space: pre;"><span>    jPCA_params.Area = area; </span><span style="color: rgb(2, 128, 9);">% Assign `Area` metadata</span></span></div></div><div class="inlineWrapper"><div  class = 'S6'><span style="white-space: pre;"><span style="color: rgb(14, 0, 255);">end</span></span></div></div><div class="inlineWrapper"><div  class = 'S6'><span style="white-space: pre;"><span style="color: rgb(14, 0, 255);">if </span><span>exist(</span><span style="color: rgb(170, 4, 249);">'align_event'</span><span>,</span><span style="color: rgb(170, 4, 249);">'var'</span><span>)~=0</span></span></div></div><div class="inlineWrapper"><div  class = 'S6'><span style="white-space: pre;"><span>    jPCA_params.Alignment = align_event; </span><span style="color: rgb(2, 128, 9);">% Assign `Alignment` metadata</span></span></div></div><div class="inlineWrapper"><div  class = 'S6'><span style="white-space: pre;"><span style="color: rgb(14, 0, 255);">end</span></span></div></div><div class="inlineWrapper"><div  class = 'S6'><span style="white-space: pre;"><span style="color: rgb(14, 0, 255);">if </span><span>exist(</span><span style="color: rgb(170, 4, 249);">'animal'</span><span>,</span><span style="color: rgb(170, 4, 249);">'var'</span><span>)~=0</span></span></div></div><div class="inlineWrapper"><div  class = 'S6'><span style="white-space: pre;"><span>    jPCA_params.Animal = animal; </span><span style="color: rgb(2, 128, 9);">% Assign `Animal` metadata</span></span></div></div><div class="inlineWrapper"><div  class = 'S6'><span style="white-space: pre;"><span style="color: rgb(14, 0, 255);">end</span></span></div></div><div class="inlineWrapper"><div  class = 'S7'><span style="white-space: pre;"><span>jPCA_params.Day = Data(1).PostOpDay; </span><span style="color: rgb(2, 128, 9);">% Assign `PostOpDay` metadata</span></span></div></div></div><div  class = 'S3'><span>With the parameters configured, make a plot to check what the data looks like:</span></div><div class="CodeBlock"><div class="inlineWrapper"><div  class = 'S2'><span style="white-space: pre;"><span>fig = analyze.marg.plot_trial_to_double_check(Data,J);</span></span></div></div></div><div  class = 'S3'><span style=' font-weight: bold;'>Top-left:</span><span> the "Original" spike rates (after an initial smoothing step, and whatever other processing has been applied, as shown in </span><span style=' font-weight: bold; font-family: monospace;'>J.Properties.UserData.Processing</span><span>). </span></div><div  class = 'S1'><span style=' font-weight: bold;'>Bottom-left: </span><span>Visually inspect that these interpolated and smoothed traces, which are used to give the data to the </span><span style=' font-weight: bold; font-family: monospace;'>jPCA </span><span>algorithm using a finer time-scale (the derivative is approximated using </span><span style=' font-weight: bold;'>differences</span><span> between consecutive time-values), have not caused the data to change drastically. </span></div><div  class = 'S1'><span style=' font-weight: bold;'>Right: </span><span>The distribution of errors shows that, for a minority of the samples, there actually is a substantial change induced by this smoothing and interpolation step; however, the majority of the sample differences are very close to zero. (</span><span style=' font-style: italic;'>Note: some of the error should be accounted for by non-exact matches of interpolated times compared to the "closest" original time, so that differences could be taken to begin with</span><span>). </span></div><h2  class = 'S8'><span>Recover </span><span style=' font-weight: bold; font-family: monospace;'>jPCA</span><span> projections and summary structure</span></h2><div  class = 'S1'><span>With the recording block trial rate data in the appropriate Data array struct, click Run jPCA to recover the single-trial Projections and skew-symmetric projection matrix that best fits the linearized dynamical system.</span></div><div class="CodeBlock"><div class="inlineWrapper"><div  class = 'S2'><span> </span><span style="white-space: pre;"><span> </span><span style="color: rgb(2, 128, 9);">% Run current section (requires `Data` (formatted struct array))</span></span></div></div></div><div  class = 'S3'><span>This part actually recovers the jPCA projections for a single trial, and depending on the configured </span><span style=' font-weight: bold; font-family: monospace;'>jPCA_params</span><span> values, displays the rosettes, phase difference histograms, and some printouts such as the eigenvalues and the amount of data explained. </span></div><div class="CodeBlock"><div class="inlineWrapper"><div  class = 'S2'><span style="white-space: pre;"><span>[Projection,Summary] = analyze.jPCA.jPCA(Data,jPCA_params);</span></span></div></div></div><div  class = 'S3'><span style=' font-weight: bold;'>Top:</span><span> The panel shows the selected jPCA plane, which is spanned by a pair of basis vectors in the linear mapping of the data such that it is best fit to its own (time) derivative. The least-squares minimization procedure that recovers this matrix is constrained such that the algorithm must recover a skew-symmetric transformation matrix, which by definition should have pairs of complex-conjugate eigenvectors indicative of a "rotatory subspace" within the neuronal population time-series dynamics. Ideally, each "rosette" arrow (an individual trial)</span></div><div  class = 'S1'><span style=' font-weight: bold;'>Bottom:</span><span> The distribution of phase angle differences between the position in jPCA-plane-space and the corresponding "velocity" of the neural trajectory at that position in jPCA-plane-space. A distribution centered about pi or -pi indicates an offset of 90 degrees between the two phase angles indicates "perfect" rotatory structure (e.g. circles) within the subspace.</span></div><h1  class = 'S0'><span style=' font-weight: bold; font-family: monospace;'>Export</span><span> jPCs in multiple alignments</span></h1><div  class = 'S1'><span>To perform a statistical analysis on the strength of rotatory subspaces captured using the jPCA method, so that we can assess trends across days (i.e. during recovery from focal ischemia), we want to export all the data in a batch as a big table, </span><span style=' font-weight: bold;'>where each row quantifies the rotatory strength of a particular plane</span><span> during a single </span><span style=' font-weight: bold; font-family: monospace;'>Trial </span><span>or as an aggregate metric from all trials in a recording </span><span style=' font-weight: bold; font-family: monospace;'>Block</span><span> in some alignment condition. The row should also indicate how much of the data is represented by this plane, and how accurately the projection matrix was able to linearize the dynamical system.</span></div><div  class = 'S1'><span>Click </span><span style=' font-weight: bold; font-family: monospace;'>Export</span><span> to run the batch export, making sure that the checkbox is clicked (toggling it to false is the default so that clicking Run at the top doesn't accidentally start the batch export, which can take a few minutes depending on settings).</span></div><div class="CodeBlock"><div class="inlineWrapper"><div  class = 'S2'><span> </span><span style="white-space: pre;"><span> </span><span style="color: rgb(2, 128, 9);">% Run the current section</span></span></div></div></div><div  class = 'S3'><span style=' font-weight: bold; font-style: italic;'>Note:</span><span style=' font-style: italic;'> jPC estimation is performed separately for each Alignment; therefore, the jPCs present during Reach may not reflect those present during Grasp. For estimating the number of PCs, in this case we always use the largest even value that is less than the total number of channels present in the data.</span></div><div class="CodeBlock"><div class="inlineWrapper"><div  class = 'S2'><span style="white-space: pre;"><span>D = analyze.jPCA.multi_jPCA(S,jPCA_params);</span></span></div></div></div></div>
<br>
<!-- 
##### SOURCE BEGIN #####
%% *jPCA*: _A Guide_
% Click |*Run*| to run the full script. Otherwise, step through (section by 
% section) to adjust parameters as desired.

  % Runs all analyses in this live-script
%% 
% Many of the population-level analyses that are described in assessments of 
% neurophysiological spiking population dynamics seek to interpret not necessarily 
% the mean firing rate, which indeed co-varies most strongly with specific elements 
% of behavior, but rather, the unaccounted variance in underlying processes (sometimes 
% referred to as factors), which might otherwise be better explained when viewed 
% in covariance of overall population "dispersion" under certain task-specific 
% conditions. This script tries to walk through that process in a sensible way.
%% Initialize |*jPCA*| Data
% Click |*Initialize*| to run the current section. Doing so will initialize 
% the main data table, excluding unwanted grouping categories (e.g. trials where 
% no pellet was present).

  % Only runs the current section
%% 
% Clear workspace & load data

clear
load(defaults.files('rate_table_default_matfile'),'T'); % Load can take a few minutes
M = analyze.marg.get_subset(T); % Reduce to relevant subset
%% Remove relevant Marginalizations
% Click |*Marginalize*| to run the current section, creating a data table of 
% mean-subtracted trial rates that corresponds to trials with zero cross-trial 
% average according to the groupings in marginalizations.

  % Run all analyses except for the LOAD step
  % Only runs the current section
% Subtract group means in a principled way
% We expect there to be large, striking differences in the observed neurophsyiological 
% spiking time-series, with this being unsurprising for the following marginalizations: 
%% 
% * |*Group*| (we expect a difference between Ischemic vs. Intact rats)
% * |*Rat*| (we expect a random within-rat difference simply due to different 
% combination of recording channels etc.)
% * |*Area*| (we expect a difference on the basis of Premotor vs. Motor area)
% * |*ICMS*| (motor representation, such as Forelimb vs. Whiskers)
% * |*Channel*| (a huge difference for individual channels)

clearvars -except T M
marginalizations = {'AnimalID','Area','Channel','Alignment','Outcome'};
outcome = 'Successful';
min_n_trials = 5;
% Create marginalized dataset

S = analyze.marg.subtract_rat_means(M,marginalizations);
S = utils.filterByNTrials(S,min_n_trials,outcome); % Restrict subset to analyze
%% 
% Set parameters:
%% 
% * |*animal*| : Exemplar Animal to use in single-recording jPCA analysis/visualization
% * |*align_event*| : Alignment event to use for single-recording jPCA analyses
% * |*save_fig*| : Toggle checkbox on if you wish to automatically save the 
% generated figure
% * |*show_pre_mean_subtraction*| : Toggle checkbox on if you want to check 
% pre-mean-subtraction data

animal = 'RC-14';
align_event = 'Grasp';
save_fig = false; % Auto-saves the figure, if ticked
show_pre_mean_subtraction = false; % Show same data, prior to mean-subtraction

% % Survey of some combinations that I've looked at % %
%   Intact group
% RC-14 - PO-05 - Grasp: same issue as some of Ischemia guys regarding
%       expansions and contractions while still having rotatory structure
% RC-18 - PO-17 - Grasp: looks good in jPCA on Plane-1
% RC-21 - PO-14 - Grasp: looks good in jPCA on Plane-1
% RC-43 - PO-24 - Grasp: looks good in jPCA on Plane-1
%
%   Ischemia group
% RC-02 - PO-17 - Grasp: not as strong jPCA structure on Plane-1
% RC-04 - PO-16 - Grasp: not as strong jPCA structure on Plane-1
% RC-05 - PO-08 - Grasp: not as strong jPCA structure on Plane-1
% RC-08 - PO-16 - Grasp: not as strong jPCA structure on Plane-1
% RC-26 - PO-19 - Grasp: definitely has separation between
%           success/unsuccesful in Plane-1, but has some elements of rotatory
%           structure combined with a lot of expansion/contraction elements.
% RC-30 - PO-16 (& others) - Grasp: has quite good jPCA structure on
%                               Plane-1. Note that on this day, he had many
%                               more successful trials included than
%                               unsuccessful trials, although the variance
%                               captured is lower in general for any of the
%                               visualized planes.
[fig_by_Channel,s] = analyze.rec.plot_rate(...
    utils.filterByNTrials(S,min_n_trials,outcome,'AnimalID',animal),... 
    align_event,outcome,save_fig,1);
%% 
% This figure produces subplots for all trials of a single Block. Each subplot 
% represents a different channel. The top two rows represent normalized spike 
% rates on channels that are in Caudal Forelimb Area (CFA; rat M1 homolog) that 
% is ipsilateral to the forelimb retrieving the pellet. The bottom two rows represent 
% normalized spike rates on channels that are in Rostral Forelimb Area (RFA; rat 
% PM homolog) contralateral to the forelimb retrieving the pellet. Time is represented 
% on the x-axis in milliseconds. The bold text above each subplot indicates the 
% approximate intracortical microstimulation (ICMS) co-registration from a mapping 
% procedure done just prior to the insertion of the microwire arrays. It follows 
% the key: 
%% 
% * *Distal Forelimb* (DF)
% * *Proximal Forelimb* (PF)
% * *Distal & Proximal Forelimb* (DF-PF)
% * *No Response* (NR; 80 uA maximum current)
% * *Other* (O; e.g. Trunk, Vibrissae, Mouth, etc.)
%% 
% Verify that the mean-subtracted outcomes make sense; the largest "modulated" 
% component should be the task-aligned one. Since we do not typically see "traditionally" 
% coherent task-related fluctuations, particularly around the 0-ms task alignment, 
% it looks like we correctly subtracted the mean. You can see if there is a difference 
% by toggling the check-box below.

if show_pre_mean_subtraction
    % Note that `M` is the pre-subtraction table
    [fig_by_Channel_orig] = analyze.rec.plot_rate(M(ismember(M.RowID,s.RowID),:),...
        align_event,outcome,save_fig,1); %#ok<UNRCH> 
end
%% Apply Population-Level Analysis
% Click |*Convert*| to create the formatted struct for analyzing the spike rates 
% of trials from a single recording using the (modified) Churchland & Cunningham 
% jPCA scripts.

  % Only runs the current section
%% 
% Using our marginalized dataset, we can now apply population-level analysis. 
% A principled approach is detailed in (cite), which describes jPCA, a method 
% that attempts to assess the strength of rotatory dynamics present under the 
% assumption that the population dynamics are the result of factors governed in 
% an oscillatory fashion, which is captured by a system of differential equations 
% as:
% 
% Where  is constrained to be skew-symmetric during the optimization procedure 
% (a least-squares minimization). The recovered fit should then be compared to 
% , which is the optimal solution in the least-squares sense. If the fits are 
% comparable (and that part can be nebulous; in general, it would seem that you 
% want the top pairs of eigenvectors to capture 20-40% of the observed data variance 
% as a seeming rule of thumb).
% Organize data for jPCA code
% _Note that all code in |*analyze.jPCA*| is based on code kindly provided by 
% John P. Cunningham & Mark Churchland; it has been changed slightly from the 
% original format to accomodate some optional parameters for visualization purposes, 
% and the documentation is changed to reflect notes as I was learning the material._
% 
% *We will use the (small-m) matrix that we inspected rates for above*

if exist('s','var')==0
    error('Must run previous section prior to this one.')
end
area = "All";
[Data,J,JID] = analyze.jPCA.convert_table(...
    s,align_event,area,...
    'Outcome',outcome);
if isempty(Data)
    error('No trials meet those criteria.');
end
% Verify |*Data*| exported as intended
% Once the Data struct has been exported for jPCA, click Check Data to plot 
% one of the exported trials, verifying that filtering/interpolating didn't do 
% anything "weird." Click |*Run*| to run the current section (_see "*Setting* 
% |*jPCA_params"| below)_.

  % Run current section (requires `Data` (formatted struct array))
if exist('Data','var')==0
    error('Must run previous section to extract `Data` first');
end
% *Setting |jPCA_params*|
% For jPCA, most parameters are set via the defaults and previously-initialized 
% variables. The following parameters can be toggled as desired:
%% 
% * |*.numPCs*| : Total number of principal components to use for obtaining 
% linearized dynamical system fit.
% * |*.PCStem.PlotMeans*| : Toggle to true in order to plot mean PC values for 
% different conditions (outcomes). Only makes sense if using more than one outcome.

jPCA_params = defaults.jPCA('jpca_params');
jPCA_params.numPCs = 12; % Note: only increments by **even** values
jPCA_params.PCStem.PlotMeans = false; % Plot means if true, otherwise plot individual trials (PCs)
%% 
% If you do not wish to see some element of the jPCA output displayed, tick 
% the corresponding checkbox:
%% 
% * |*.suppressPCstem :*| Stem plot showing % of original data explained by 
% selected |*.numPCs*| parameter.
% * |*.suppressRosettes :*| Arrow "rosette" plots showing individual trial phase 
% trajectories.
% * |*.suppressHistograms :*| Phase-angle histogram displays.
% * |*.suppressText :*| Formatted text reporting eigenvalues and % of data explained 
% and % variance captured.

jPCA_params.suppressPCstem = false; % Set true to suppress PC stem plot
jPCA_params.suppressRosettes = false; % Set true to suppress jPC rosette planar plots
jPCA_params.suppressHistograms = false; % Set true to suppress jPC plane phase angle histograms
jPCA_params.suppressText = false; % Set true to suppress text output
%% 
% For plot titles etc. we associate metadata with the parameters struct, but 
% there are no actual parameters to "set" here:

if exist('area','var')~=0
    jPCA_params.Area = area; % Assign `Area` metadata
end
if exist('align_event','var')~=0
    jPCA_params.Alignment = align_event; % Assign `Alignment` metadata
end
if exist('animal','var')~=0
    jPCA_params.Animal = animal; % Assign `Animal` metadata
end
jPCA_params.Day = Data(1).PostOpDay; % Assign `PostOpDay` metadata
%% 
% With the parameters configured, make a plot to check what the data looks like:

fig = analyze.marg.plot_trial_to_double_check(Data,J);
%% 
% *Top-left:* the "Original" spike rates (after an initial smoothing step, and 
% whatever other processing has been applied, as shown in |*J.Properties.UserData.Processing*|). 
% 
% *Bottom-left:* Visually inspect that these interpolated and smoothed traces, 
% which are used to give the data to the |*jPCA*| algorithm using a finer time-scale 
% (the derivative is approximated using *differences* between consecutive time-values), 
% have not caused the data to change drastically. 
% 
% *Right:* The distribution of errors shows that, for a minority of the samples, 
% there actually is a substantial change induced by this smoothing and interpolation 
% step; however, the majority of the sample differences are very close to zero. 
% (_Note: some of the error should be accounted for by non-exact matches of interpolated 
% times compared to the "closest" original time, so that differences could be 
% taken to begin with_). 
%% Recover |*jPCA*| projections and summary structure
% With the recording block trial rate data in the appropriate Data array struct, 
% click Run jPCA to recover the single-trial Projections and skew-symmetric projection 
% matrix that best fits the linearized dynamical system.

  % Run current section (requires `Data` (formatted struct array))
%% 
% This part actually recovers the jPCA projections for a single trial, and depending 
% on the configured |*jPCA_params*| values, displays the rosettes, phase difference 
% histograms, and some printouts such as the eigenvalues and the amount of data 
% explained. 

[Projection,Summary] = analyze.jPCA.jPCA(Data,jPCA_params);
%% 
% *Top:* The panel shows the selected jPCA plane, which is spanned by a pair 
% of basis vectors in the linear mapping of the data such that it is best fit 
% to its own (time) derivative. The least-squares minimization procedure that 
% recovers this matrix is constrained such that the algorithm must recover a skew-symmetric 
% transformation matrix, which by definition should have pairs of complex-conjugate 
% eigenvectors indicative of a "rotatory subspace" within the neuronal population 
% time-series dynamics. Ideally, each "rosette" arrow (an individual trial)
% 
% *Bottom:* The distribution of phase angle differences between the position 
% in jPCA-plane-space and the corresponding "velocity" of the neural trajectory 
% at that position in jPCA-plane-space. A distribution centered about pi or -pi 
% indicates an offset of 90 degrees between the two phase angles indicates "perfect" 
% rotatory structure (e.g. circles) within the subspace.
%% |*Export*| jPCs in multiple alignments
% To perform a statistical analysis on the strength of rotatory subspaces captured 
% using the jPCA method, so that we can assess trends across days (i.e. during 
% recovery from focal ischemia), we want to export all the data in a batch as 
% a big table, *where each row quantifies the rotatory strength of a particular 
% plane* during a single |*Trial*| or as an aggregate metric from all trials in 
% a recording |*Block*| in some alignment condition. The row should also indicate 
% how much of the data is represented by this plane, and how accurately the projection 
% matrix was able to linearize the dynamical system.
% 
% Click |*Export*| to run the batch export, making sure that the checkbox is 
% clicked (toggling it to false is the default so that clicking Run at the top 
% doesn't accidentally start the batch export, which can take a few minutes depending 
% on settings).

  % Run the current section
%% 
% _*Note:* jPC estimation is performed separately for each Alignment; therefore, 
% the jPCs present during Reach may not reflect those present during Grasp. For 
% estimating the number of PCs, in this case we always use the largest even value 
% that is less than the total number of channels present in the data._

D = analyze.jPCA.multi_jPCA(S,jPCA_params);
##### SOURCE END #####
--></body></html>